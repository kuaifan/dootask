/*! OpenPGP.js v5.7.0 - 2023-05-29 - this is LGPL licensed code, see LICENSE/our website https://openpgpjs.org/ for more information. */const b=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?Symbol:e=>`Symbol(${e})`;function dt(){}const Ot=typeof self!="undefined"?self:typeof window!="undefined"?window:typeof global!="undefined"?global:void 0;function E(e){return typeof e=="object"&&e!==null||typeof e=="function"}const Jt=dt,ft=Promise,xr=Promise.prototype.then,Nr=Promise.resolve.bind(ft),Qr=Promise.reject.bind(ft);function q(e){return new ft(e)}function v(e){return Nr(e)}function d(e){return Qr(e)}function z(e,t,r){return xr.call(e,t,r)}function O(e,t,r){z(z(e,t,r),void 0,Jt)}function Ye(e,t){O(e,t)}function Kt(e,t){O(e,void 0,t)}function G(e,t,r){return z(e,t,r)}function he(e){z(e,void 0,Jt)}const Zt=(()=>{const e=Ot&&Ot.queueMicrotask;if(typeof e=="function")return e;const t=v(void 0);return r=>z(t,r)})();function Le(e,t,r){if(typeof e!="function")throw new TypeError("Argument is not a function");return Function.prototype.apply.call(e,t,r)}function K(e,t,r){try{return v(Le(e,t,r))}catch(o){return d(o)}}class A{constructor(){this._cursor=0,this._size=0,this._front={_elements:[],_next:void 0},this._back=this._front,this._cursor=0,this._size=0}get length(){return this._size}push(t){const r=this._back;let o=r;r._elements.length===16383&&(o={_elements:[],_next:void 0}),r._elements.push(t),o!==r&&(this._back=o,r._next=o),++this._size}shift(){const t=this._front;let r=t;const o=this._cursor;let n=o+1;const i=t._elements,s=i[o];return n===16384&&(r=t._next,n=0),--this._size,this._cursor=n,t!==r&&(this._front=r),i[o]=void 0,s}forEach(t){let r=this._cursor,o=this._front,n=o._elements;for(;!(r===n.length&&o._next===void 0||r===n.length&&(o=o._next,n=o._elements,r=0,n.length===0));)t(n[r]),++r}peek(){const t=this._front,r=this._cursor;return t._elements[r]}}function er(e,t){e._ownerReadableStream=t,t._reader=e,t._state==="readable"?Ge(e):t._state==="closed"?function(r){Ge(r),rr(r)}(e):tr(e,t._storedError)}function ht(e,t){return X(e._ownerReadableStream,t)}function V(e){e._ownerReadableStream._state==="readable"?_t(e,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")):function(t,r){tr(t,r)}(e,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")),e._ownerReadableStream._reader=void 0,e._ownerReadableStream=void 0}function oe(e){return new TypeError("Cannot "+e+" a stream using a released reader")}function Ge(e){e._closedPromise=q((t,r)=>{e._closedPromise_resolve=t,e._closedPromise_reject=r})}function tr(e,t){Ge(e),_t(e,t)}function _t(e,t){e._closedPromise_reject!==void 0&&(he(e._closedPromise),e._closedPromise_reject(t),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0)}function rr(e){e._closedPromise_resolve!==void 0&&(e._closedPromise_resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0)}const or=b("[[AbortSteps]]"),nr=b("[[ErrorSteps]]"),bt=b("[[CancelSteps]]"),pt=b("[[PullSteps]]"),Wt=Number.isFinite||function(e){return typeof e=="number"&&isFinite(e)},Yr=Math.trunc||function(e){return e<0?Math.ceil(e):Math.floor(e)};function B(e,t){if(e!==void 0&&typeof(r=e)!="object"&&typeof r!="function")throw new TypeError(t+" is not an object.");var r}function W(e,t){if(typeof e!="function")throw new TypeError(t+" is not a function.")}function ir(e,t){if(!function(r){return typeof r=="object"&&r!==null||typeof r=="function"}(e))throw new TypeError(t+" is not an object.")}function F(e,t,r){if(e===void 0)throw new TypeError(`Parameter ${t} is required in '${r}'.`)}function Xe(e,t,r){if(e===void 0)throw new TypeError(`${t} is required in '${r}'.`)}function mt(e){return Number(e)}function jt(e){return e===0?0:e}function ar(e,t){const r=Number.MAX_SAFE_INTEGER;let o=Number(e);if(o=jt(o),!Wt(o))throw new TypeError(t+" is not a finite number");if(o=function(n){return jt(Yr(n))}(o),o<0||o>r)throw new TypeError(`${t} is outside the accepted range of 0 to ${r}, inclusive`);return Wt(o)&&o!==0?o:0}function yt(e,t){if(!$(e))throw new TypeError(t+" is not a ReadableStream.")}function Re(e){return new Je(e)}function sr(e,t){e._reader._readRequests.push(t)}function gt(e,t,r){const o=e._reader._readRequests.shift();r?o._closeSteps():o._chunkSteps(t)}function Me(e){return e._reader._readRequests.length}function lr(e){const t=e._reader;return t!==void 0&&!!U(t)}class Je{constructor(t){if(F(t,1,"ReadableStreamDefaultReader"),yt(t,"First parameter"),D(t))throw new TypeError("This stream has already been locked for exclusive reading by another reader");er(this,t),this._readRequests=new A}get closed(){return U(this)?this._closedPromise:d(be("closed"))}cancel(t=void 0){return U(this)?this._ownerReadableStream===void 0?d(oe("cancel")):ht(this,t):d(be("cancel"))}read(){if(!U(this))return d(be("read"));if(this._ownerReadableStream===void 0)return d(oe("read from"));let t,r;const o=q((n,i)=>{t=n,r=i});return $e(this,{_chunkSteps:n=>t({value:n,done:!1}),_closeSteps:()=>t({value:void 0,done:!0}),_errorSteps:n=>r(n)}),o}releaseLock(){if(!U(this))throw be("releaseLock");if(this._ownerReadableStream!==void 0){if(this._readRequests.length>0)throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");V(this)}}}function U(e){return!!E(e)&&!!Object.prototype.hasOwnProperty.call(e,"_readRequests")}function $e(e,t){const r=e._ownerReadableStream;r._disturbed=!0,r._state==="closed"?t._closeSteps():r._state==="errored"?t._errorSteps(r._storedError):r._readableStreamController[pt](t)}function be(e){return new TypeError(`ReadableStreamDefaultReader.prototype.${e} can only be used on a ReadableStreamDefaultReader`)}let qe;Object.defineProperties(Je.prototype,{cancel:{enumerable:!0},read:{enumerable:!0},releaseLock:{enumerable:!0},closed:{enumerable:!0}}),typeof b.toStringTag=="symbol"&&Object.defineProperty(Je.prototype,b.toStringTag,{value:"ReadableStreamDefaultReader",configurable:!0}),typeof b.asyncIterator=="symbol"&&(qe={[b.asyncIterator](){return this}},Object.defineProperty(qe,b.asyncIterator,{enumerable:!1}));class Hr{constructor(t,r){this._ongoingPromise=void 0,this._isFinished=!1,this._reader=t,this._preventCancel=r}next(){const t=()=>this._nextSteps();return this._ongoingPromise=this._ongoingPromise?G(this._ongoingPromise,t,t):t(),this._ongoingPromise}return(t){const r=()=>this._returnSteps(t);return this._ongoingPromise?G(this._ongoingPromise,r,r):r()}_nextSteps(){if(this._isFinished)return Promise.resolve({value:void 0,done:!0});const t=this._reader;if(t._ownerReadableStream===void 0)return d(oe("iterate"));let r,o;const n=q((i,s)=>{r=i,o=s});return $e(t,{_chunkSteps:i=>{this._ongoingPromise=void 0,Zt(()=>r({value:i,done:!1}))},_closeSteps:()=>{this._ongoingPromise=void 0,this._isFinished=!0,V(t),r({value:void 0,done:!0})},_errorSteps:i=>{this._ongoingPromise=void 0,this._isFinished=!0,V(t),o(i)}}),n}_returnSteps(t){if(this._isFinished)return Promise.resolve({value:t,done:!0});this._isFinished=!0;const r=this._reader;if(r._ownerReadableStream===void 0)return d(oe("finish iterating"));if(!this._preventCancel){const o=ht(r,t);return V(r),G(o,()=>({value:t,done:!0}))}return V(r),v({value:t,done:!0})}}const ur={next(){return At(this)?this._asyncIteratorImpl.next():d(zt("next"))},return(e){return At(this)?this._asyncIteratorImpl.return(e):d(zt("return"))}};function At(e){return!!E(e)&&!!Object.prototype.hasOwnProperty.call(e,"_asyncIteratorImpl")}function zt(e){return new TypeError(`ReadableStreamAsyncIterator.${e} can only be used on a ReadableSteamAsyncIterator`)}qe!==void 0&&Object.setPrototypeOf(ur,qe);const cr=Number.isNaN||function(e){return e!=e};function dr(e){return!!function(t){return!(typeof t!="number"||cr(t)||t<0)}(e)&&e!==1/0}function Ke(e){const t=e._queue.shift();return e._queueTotalSize-=t.size,e._queueTotalSize<0&&(e._queueTotalSize=0),t.value}function vt(e,t,r){if(!dr(r=Number(r)))throw new RangeError("Size must be a finite, non-NaN, non-negative number.");e._queue.push({value:t,size:r}),e._queueTotalSize+=r}function N(e){e._queue=new A,e._queueTotalSize=0}function He(e){return e.slice()}class Ze{constructor(){throw new TypeError("Illegal constructor")}get view(){if(!Ve(this))throw Ue("view");return this._view}respond(t){if(!Ve(this))throw Ue("respond");if(F(t,1,"respond"),t=ar(t,"First parameter"),this._associatedReadableByteStreamController===void 0)throw new TypeError("This BYOB request has been invalidated");this._view.buffer,function(r,o){if(o=Number(o),!dr(o))throw new RangeError("bytesWritten must be a finite");Bt(r,o)}(this._associatedReadableByteStreamController,t)}respondWithNewView(t){if(!Ve(this))throw Ue("respondWithNewView");if(F(t,1,"respondWithNewView"),!ArrayBuffer.isView(t))throw new TypeError("You can only respond with array buffer views");if(t.byteLength===0)throw new TypeError("chunk must have non-zero byteLength");if(t.buffer.byteLength===0)throw new TypeError("chunk's buffer must have non-zero byteLength");if(this._associatedReadableByteStreamController===void 0)throw new TypeError("This BYOB request has been invalidated");(function(r,o){const n=r._pendingPullIntos.peek();if(n.byteOffset+n.bytesFilled!==o.byteOffset)throw new RangeError("The region specified by view does not match byobRequest");if(n.byteLength!==o.byteLength)throw new RangeError("The buffer of view has different capacity than byobRequest");n.buffer=o.buffer,Bt(r,o.byteLength)})(this._associatedReadableByteStreamController,t)}}Object.defineProperties(Ze.prototype,{respond:{enumerable:!0},respondWithNewView:{enumerable:!0},view:{enumerable:!0}}),typeof b.toStringTag=="symbol"&&Object.defineProperty(Ze.prototype,b.toStringTag,{value:"ReadableStreamBYOBRequest",configurable:!0});class et{constructor(){throw new TypeError("Illegal constructor")}get byobRequest(){if(!ee(this))throw ie("byobRequest");if(this._byobRequest===null&&this._pendingPullIntos.length>0){const t=this._pendingPullIntos.peek(),r=new Uint8Array(t.buffer,t.byteOffset+t.bytesFilled,t.byteLength-t.bytesFilled),o=Object.create(Ze.prototype);(function(n,i,s){n._associatedReadableByteStreamController=i,n._view=s})(o,this,r),this._byobRequest=o}return this._byobRequest}get desiredSize(){if(!ee(this))throw ie("desiredSize");return mr(this)}close(){if(!ee(this))throw ie("close");if(this._closeRequested)throw new TypeError("The stream has already been closed; do not close it again!");const t=this._controlledReadableByteStream._state;if(t!=="readable")throw new TypeError(`The stream (in ${t} state) is not in the readable state and cannot be closed`);(function(r){const o=r._controlledReadableByteStream;if(!(r._closeRequested||o._state!=="readable")){if(r._queueTotalSize>0)return void(r._closeRequested=!0);if(r._pendingPullIntos.length>0&&r._pendingPullIntos.peek().bytesFilled>0){const n=new TypeError("Insufficient bytes to fill elements in the given buffer");throw ue(r,n),n}Ee(r),_e(o)}})(this)}enqueue(t){if(!ee(this))throw ie("enqueue");if(F(t,1,"enqueue"),!ArrayBuffer.isView(t))throw new TypeError("chunk must be an array buffer view");if(t.byteLength===0)throw new TypeError("chunk must have non-zero byteLength");if(t.buffer.byteLength===0)throw new TypeError("chunk's buffer must have non-zero byteLength");if(this._closeRequested)throw new TypeError("stream is closed or draining");const r=this._controlledReadableByteStream._state;if(r!=="readable")throw new TypeError(`The stream (in ${r} state) is not in the readable state and cannot be enqueued to`);(function(o,n){const i=o._controlledReadableByteStream;if(o._closeRequested||i._state!=="readable")return;const s=n.buffer,a=n.byteOffset,l=n.byteLength,u=s;lr(i)?Me(i)===0?Te(o,u,a,l):gt(i,new Uint8Array(u,a,l),!1):St(i)?(Te(o,u,a,l),pr(o)):Te(o,u,a,l),J(o)})(this,t)}error(t=void 0){if(!ee(this))throw ie("error");ue(this,t)}[bt](t){this._pendingPullIntos.length>0&&(this._pendingPullIntos.peek().bytesFilled=0),N(this);const r=this._cancelAlgorithm(t);return Ee(this),r}[pt](t){const r=this._controlledReadableByteStream;if(this._queueTotalSize>0){const n=this._queue.shift();this._queueTotalSize-=n.byteLength,br(this);const i=new Uint8Array(n.buffer,n.byteOffset,n.byteLength);return void t._chunkSteps(i)}const o=this._autoAllocateChunkSize;if(o!==void 0){let n;try{n=new ArrayBuffer(o)}catch(s){return void t._errorSteps(s)}const i={buffer:n,byteOffset:0,byteLength:o,bytesFilled:0,elementSize:1,viewConstructor:Uint8Array,readerType:"default"};this._pendingPullIntos.push(i)}sr(r,t),J(this)}}function ee(e){return!!E(e)&&!!Object.prototype.hasOwnProperty.call(e,"_controlledReadableByteStream")}function Ve(e){return!!E(e)&&!!Object.prototype.hasOwnProperty.call(e,"_associatedReadableByteStreamController")}function J(e){if(!!function(r){const o=r._controlledReadableByteStream;return o._state!=="readable"||r._closeRequested||!r._started?!1:!!(lr(o)&&Me(o)>0||St(o)&&yr(o)>0||mr(r)>0)}(e)){if(e._pulling)return void(e._pullAgain=!0);e._pulling=!0,O(e._pullAlgorithm(),()=>{e._pulling=!1,e._pullAgain&&(e._pullAgain=!1,J(e))},r=>{ue(e,r)})}}function tt(e,t){let r=!1;e._state==="closed"&&(r=!0);const o=fr(t);t.readerType==="default"?gt(e,o,r):function(n,i,s){const a=n._reader,l=a._readIntoRequests.shift();s?l._closeSteps(i):l._chunkSteps(i)}(e,o,r)}function fr(e){const t=e.bytesFilled,r=e.elementSize;return new e.viewConstructor(e.buffer,e.byteOffset,t/r)}function Te(e,t,r,o){e._queue.push({buffer:t,byteOffset:r,byteLength:o}),e._queueTotalSize+=o}function hr(e,t){const r=t.elementSize,o=t.bytesFilled-t.bytesFilled%r,n=Math.min(e._queueTotalSize,t.byteLength-t.bytesFilled),i=t.bytesFilled+n,s=i-i%r;let a=n,l=!1;s>o&&(a=s-t.bytesFilled,l=!0);const u=e._queue;for(;a>0;){const m=u.peek(),h=Math.min(a,m.byteLength),S=t.byteOffset+t.bytesFilled;f=t.buffer,_=S,c=m.buffer,y=m.byteOffset,g=h,new Uint8Array(f).set(new Uint8Array(c,y,g),_),m.byteLength===h?u.shift():(m.byteOffset+=h,m.byteLength-=h),e._queueTotalSize-=h,_r(e,h,t),a-=h}var f,_,c,y,g;return l}function _r(e,t,r){wt(e),r.bytesFilled+=t}function br(e){e._queueTotalSize===0&&e._closeRequested?(Ee(e),_e(e._controlledReadableByteStream)):J(e)}function wt(e){e._byobRequest!==null&&(e._byobRequest._associatedReadableByteStreamController=void 0,e._byobRequest._view=null,e._byobRequest=null)}function pr(e){for(;e._pendingPullIntos.length>0;){if(e._queueTotalSize===0)return;const t=e._pendingPullIntos.peek();hr(e,t)&&(rt(e),tt(e._controlledReadableByteStream,t))}}function Bt(e,t){const r=e._pendingPullIntos.peek();if(e._controlledReadableByteStream._state==="closed"){if(t!==0)throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");(function(o,n){n.buffer=n.buffer;const i=o._controlledReadableByteStream;if(St(i))for(;yr(i)>0;)tt(i,rt(o))})(e,r)}else(function(o,n,i){if(i.bytesFilled+n>i.byteLength)throw new RangeError("bytesWritten out of range");if(_r(o,n,i),i.bytesFilled<i.elementSize)return;rt(o);const s=i.bytesFilled%i.elementSize;if(s>0){const a=i.byteOffset+i.bytesFilled,l=i.buffer.slice(a-s,a);Te(o,l,0,l.byteLength)}i.buffer=i.buffer,i.bytesFilled-=s,tt(o._controlledReadableByteStream,i),pr(o)})(e,t,r);J(e)}function rt(e){const t=e._pendingPullIntos.shift();return wt(e),t}function Ee(e){e._pullAlgorithm=void 0,e._cancelAlgorithm=void 0}function ue(e,t){const r=e._controlledReadableByteStream;r._state==="readable"&&(function(o){wt(o),o._pendingPullIntos=new A}(e),N(e),Ee(e),Ir(r,t))}function mr(e){const t=e._controlledReadableByteStream._state;return t==="errored"?null:t==="closed"?0:e._strategyHWM-e._queueTotalSize}function Vr(e,t,r){const o=Object.create(et.prototype);let n=()=>{},i=()=>v(void 0),s=()=>v(void 0);t.start!==void 0&&(n=()=>t.start(o)),t.pull!==void 0&&(i=()=>t.pull(o)),t.cancel!==void 0&&(s=l=>t.cancel(l));const a=t.autoAllocateChunkSize;if(a===0)throw new TypeError("autoAllocateChunkSize must be greater than 0");(function(l,u,f,_,c,y,g){u._controlledReadableByteStream=l,u._pullAgain=!1,u._pulling=!1,u._byobRequest=null,u._queue=u._queueTotalSize=void 0,N(u),u._closeRequested=!1,u._started=!1,u._strategyHWM=y,u._pullAlgorithm=_,u._cancelAlgorithm=c,u._autoAllocateChunkSize=g,u._pendingPullIntos=new A,l._readableStreamController=u,O(v(f()),()=>{u._started=!0,J(u)},m=>{ue(u,m)})})(e,o,n,i,s,r,a)}function Ue(e){return new TypeError(`ReadableStreamBYOBRequest.prototype.${e} can only be used on a ReadableStreamBYOBRequest`)}function ie(e){return new TypeError(`ReadableByteStreamController.prototype.${e} can only be used on a ReadableByteStreamController`)}function Ft(e,t){e._reader._readIntoRequests.push(t)}function yr(e){return e._reader._readIntoRequests.length}function St(e){const t=e._reader;return t!==void 0&&!!ae(t)}Object.defineProperties(et.prototype,{close:{enumerable:!0},enqueue:{enumerable:!0},error:{enumerable:!0},byobRequest:{enumerable:!0},desiredSize:{enumerable:!0}}),typeof b.toStringTag=="symbol"&&Object.defineProperty(et.prototype,b.toStringTag,{value:"ReadableByteStreamController",configurable:!0});class ot{constructor(t){if(F(t,1,"ReadableStreamBYOBReader"),yt(t,"First parameter"),D(t))throw new TypeError("This stream has already been locked for exclusive reading by another reader");if(!ee(t._readableStreamController))throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");er(this,t),this._readIntoRequests=new A}get closed(){return ae(this)?this._closedPromise:d(pe("closed"))}cancel(t=void 0){return ae(this)?this._ownerReadableStream===void 0?d(oe("cancel")):ht(this,t):d(pe("cancel"))}read(t){if(!ae(this))return d(pe("read"));if(!ArrayBuffer.isView(t))return d(new TypeError("view must be an array buffer view"));if(t.byteLength===0)return d(new TypeError("view must have non-zero byteLength"));if(t.buffer.byteLength===0)return d(new TypeError("view's buffer must have non-zero byteLength"));if(this._ownerReadableStream===void 0)return d(oe("read from"));let r,o;const n=q((i,s)=>{r=i,o=s});return function(i,s,a){const l=i._ownerReadableStream;l._disturbed=!0,l._state==="errored"?a._errorSteps(l._storedError):function(u,f,_){const c=u._controlledReadableByteStream;let y=1;f.constructor!==DataView&&(y=f.constructor.BYTES_PER_ELEMENT);const g=f.constructor,m={buffer:f.buffer,byteOffset:f.byteOffset,byteLength:f.byteLength,bytesFilled:0,elementSize:y,viewConstructor:g,readerType:"byob"};if(u._pendingPullIntos.length>0)return u._pendingPullIntos.push(m),void Ft(c,_);if(c._state!=="closed"){if(u._queueTotalSize>0){if(hr(u,m)){const h=fr(m);return br(u),void _._chunkSteps(h)}if(u._closeRequested){const h=new TypeError("Insufficient bytes to fill elements in the given buffer");return ue(u,h),void _._errorSteps(h)}}u._pendingPullIntos.push(m),Ft(c,_),J(u)}else{const h=new g(m.buffer,m.byteOffset,0);_._closeSteps(h)}}(l._readableStreamController,s,a)}(this,t,{_chunkSteps:i=>r({value:i,done:!1}),_closeSteps:i=>r({value:i,done:!0}),_errorSteps:i=>o(i)}),n}releaseLock(){if(!ae(this))throw pe("releaseLock");if(this._ownerReadableStream!==void 0){if(this._readIntoRequests.length>0)throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");V(this)}}}function ae(e){return!!E(e)&&!!Object.prototype.hasOwnProperty.call(e,"_readIntoRequests")}function pe(e){return new TypeError(`ReadableStreamBYOBReader.prototype.${e} can only be used on a ReadableStreamBYOBReader`)}function ce(e,t){const{highWaterMark:r}=e;if(r===void 0)return t;if(cr(r)||r<0)throw new RangeError("Invalid highWaterMark");return r}function Ce(e){const{size:t}=e;return t||(()=>1)}function ke(e,t){B(e,t);const r=e==null?void 0:e.highWaterMark,o=e==null?void 0:e.size;return{highWaterMark:r===void 0?void 0:mt(r),size:o===void 0?void 0:Ur(o,t+" has member 'size' that")}}function Ur(e,t){return W(e,t),r=>mt(e(r))}function Gr(e,t,r){return W(e,r),o=>K(e,t,[o])}function Xr(e,t,r){return W(e,r),()=>K(e,t,[])}function Jr(e,t,r){return W(e,r),o=>Le(e,t,[o])}function Kr(e,t,r){return W(e,r),(o,n)=>K(e,t,[o,n])}function gr(e,t){if(!te(e))throw new TypeError(t+" is not a WritableStream.")}Object.defineProperties(ot.prototype,{cancel:{enumerable:!0},read:{enumerable:!0},releaseLock:{enumerable:!0},closed:{enumerable:!0}}),typeof b.toStringTag=="symbol"&&Object.defineProperty(ot.prototype,b.toStringTag,{value:"ReadableStreamBYOBReader",configurable:!0});class nt{constructor(t={},r={}){t===void 0?t=null:ir(t,"First parameter");const o=ke(r,"Second parameter"),n=function(s,a){B(s,a);const l=s==null?void 0:s.abort,u=s==null?void 0:s.close,f=s==null?void 0:s.start,_=s==null?void 0:s.type,c=s==null?void 0:s.write;return{abort:l===void 0?void 0:Gr(l,s,a+" has member 'abort' that"),close:u===void 0?void 0:Xr(u,s,a+" has member 'close' that"),start:f===void 0?void 0:Jr(f,s,a+" has member 'start' that"),write:c===void 0?void 0:Kr(c,s,a+" has member 'write' that"),type:_}}(t,"First parameter");if(wr(this),n.type!==void 0)throw new RangeError("Invalid type is specified");const i=Ce(o);(function(s,a,l,u){const f=Object.create(We.prototype);let _=()=>{},c=()=>v(void 0),y=()=>v(void 0),g=()=>v(void 0);a.start!==void 0&&(_=()=>a.start(f)),a.write!==void 0&&(c=m=>a.write(m,f)),a.close!==void 0&&(y=()=>a.close()),a.abort!==void 0&&(g=m=>a.abort(m)),Cr(s,f,_,c,y,g,l,u)})(this,n,ce(o,1),i)}get locked(){if(!te(this))throw ye("locked");return re(this)}abort(t=void 0){return te(this)?re(this)?d(new TypeError("Cannot abort a stream that already has a writer")):Oe(this,t):d(ye("abort"))}close(){return te(this)?re(this)?d(new TypeError("Cannot close a stream that already has a writer")):j(this)?d(new TypeError("Cannot close an already-closing stream")):Sr(this):d(ye("close"))}getWriter(){if(!te(this))throw ye("getWriter");return vr(this)}}function vr(e){return new at(e)}function wr(e){e._state="writable",e._storedError=void 0,e._writer=void 0,e._writableStreamController=void 0,e._writeRequests=new A,e._inFlightWriteRequest=void 0,e._closeRequest=void 0,e._inFlightCloseRequest=void 0,e._pendingAbortRequest=void 0,e._backpressure=!1}function te(e){return!!E(e)&&!!Object.prototype.hasOwnProperty.call(e,"_writableStreamController")}function re(e){return e._writer!==void 0}function Oe(e,t){const r=e._state;if(r==="closed"||r==="errored")return v(void 0);if(e._pendingAbortRequest!==void 0)return e._pendingAbortRequest._promise;let o=!1;r==="erroring"&&(o=!0,t=void 0);const n=q((i,s)=>{e._pendingAbortRequest={_promise:void 0,_resolve:i,_reject:s,_reason:t,_wasAlreadyErroring:o}});return e._pendingAbortRequest._promise=n,o||Rt(e,t),n}function Sr(e){const t=e._state;if(t==="closed"||t==="errored")return d(new TypeError(`The stream (in ${t} state) is not in the writable state and cannot be closed`));const r=q((i,s)=>{const a={_resolve:i,_reject:s};e._closeRequest=a}),o=e._writer;var n;return o!==void 0&&e._backpressure&&t==="writable"&&Ct(o),vt(n=e._writableStreamController,Er,0),De(n),r}function it(e,t){e._state!=="writable"?Tt(e):Rt(e,t)}function Rt(e,t){const r=e._writableStreamController;e._state="erroring",e._storedError=t;const o=e._writer;o!==void 0&&Tr(o,t),!function(n){return!(n._inFlightWriteRequest===void 0&&n._inFlightCloseRequest===void 0)}(e)&&r._started&&Tt(e)}function Tt(e){e._state="errored",e._writableStreamController[nr]();const t=e._storedError;if(e._writeRequests.forEach(o=>{o._reject(t)}),e._writeRequests=new A,e._pendingAbortRequest===void 0)return void me(e);const r=e._pendingAbortRequest;if(e._pendingAbortRequest=void 0,r._wasAlreadyErroring)return r._reject(t),void me(e);O(e._writableStreamController[or](r._reason),()=>{r._resolve(),me(e)},o=>{r._reject(o),me(e)})}function j(e){return e._closeRequest!==void 0||e._inFlightCloseRequest!==void 0}function me(e){e._closeRequest!==void 0&&(e._closeRequest._reject(e._storedError),e._closeRequest=void 0);const t=e._writer;t!==void 0&&Et(t,e._storedError)}function Pt(e,t){const r=e._writer;r!==void 0&&t!==e._backpressure&&(t?function(o){xe(o)}(r):Ct(r)),e._backpressure=t}Object.defineProperties(nt.prototype,{abort:{enumerable:!0},close:{enumerable:!0},getWriter:{enumerable:!0},locked:{enumerable:!0}}),typeof b.toStringTag=="symbol"&&Object.defineProperty(nt.prototype,b.toStringTag,{value:"WritableStream",configurable:!0});class at{constructor(t){if(F(t,1,"WritableStreamDefaultWriter"),gr(t,"First parameter"),re(t))throw new TypeError("This stream has already been locked for exclusive writing by another writer");this._ownerWritableStream=t,t._writer=this;const r=t._state;if(r==="writable")!j(t)&&t._backpressure?xe(this):It(this),Pe(this);else if(r==="erroring")lt(this,t._storedError),Pe(this);else if(r==="closed")It(this),Pe(o=this),jr(o);else{const n=t._storedError;lt(this,n),Wr(this,n)}var o}get closed(){return Q(this)?this._closedPromise:d(Y("closed"))}get desiredSize(){if(!Q(this))throw Y("desiredSize");if(this._ownerWritableStream===void 0)throw se("desiredSize");return function(t){const r=t._ownerWritableStream,o=r._state;return o==="errored"||o==="erroring"?null:o==="closed"?0:kr(r._writableStreamController)}(this)}get ready(){return Q(this)?this._readyPromise:d(Y("ready"))}abort(t=void 0){return Q(this)?this._ownerWritableStream===void 0?d(se("abort")):function(r,o){return Oe(r._ownerWritableStream,o)}(this,t):d(Y("abort"))}close(){if(!Q(this))return d(Y("close"));const t=this._ownerWritableStream;return t===void 0?d(se("close")):j(t)?d(new TypeError("Cannot close an already-closing stream")):Rr(this)}releaseLock(){if(!Q(this))throw Y("releaseLock");this._ownerWritableStream!==void 0&&Pr(this)}write(t=void 0){return Q(this)?this._ownerWritableStream===void 0?d(se("write to")):qr(this,t):d(Y("write"))}}function Q(e){return!!E(e)&&!!Object.prototype.hasOwnProperty.call(e,"_ownerWritableStream")}function Rr(e){return Sr(e._ownerWritableStream)}function Zr(e,t){e._closedPromiseState==="pending"?Et(e,t):function(r,o){Wr(r,o)}(e,t)}function Tr(e,t){e._readyPromiseState==="pending"?Ar(e,t):function(r,o){lt(r,o)}(e,t)}function Pr(e){const t=e._ownerWritableStream,r=new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");Tr(e,r),Zr(e,r),t._writer=void 0,e._ownerWritableStream=void 0}function qr(e,t){const r=e._ownerWritableStream,o=r._writableStreamController,n=function(a,l){try{return a._strategySizeAlgorithm(l)}catch(u){return st(a,u),1}}(o,t);if(r!==e._ownerWritableStream)return d(se("write to"));const i=r._state;if(i==="errored")return d(r._storedError);if(j(r)||i==="closed")return d(new TypeError("The stream is closing or closed and cannot be written to"));if(i==="erroring")return d(r._storedError);const s=function(a){return q((l,u)=>{const f={_resolve:l,_reject:u};a._writeRequests.push(f)})}(r);return function(a,l,u){try{vt(a,l,u)}catch(_){return void st(a,_)}const f=a._controlledWritableStream;!j(f)&&f._state==="writable"&&Pt(f,qt(a)),De(a)}(o,t,n),s}Object.defineProperties(at.prototype,{abort:{enumerable:!0},close:{enumerable:!0},releaseLock:{enumerable:!0},write:{enumerable:!0},closed:{enumerable:!0},desiredSize:{enumerable:!0},ready:{enumerable:!0}}),typeof b.toStringTag=="symbol"&&Object.defineProperty(at.prototype,b.toStringTag,{value:"WritableStreamDefaultWriter",configurable:!0});const Er={};class We{constructor(){throw new TypeError("Illegal constructor")}error(t=void 0){if(!function(r){return!(!E(r)||!Object.prototype.hasOwnProperty.call(r,"_controlledWritableStream"))}(this))throw new TypeError("WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController");this._controlledWritableStream._state==="writable"&&Or(this,t)}[or](t){const r=this._abortAlgorithm(t);return je(this),r}[nr](){N(this)}}function Cr(e,t,r,o,n,i,s,a){t._controlledWritableStream=e,e._writableStreamController=t,t._queue=void 0,t._queueTotalSize=void 0,N(t),t._started=!1,t._strategySizeAlgorithm=a,t._strategyHWM=s,t._writeAlgorithm=o,t._closeAlgorithm=n,t._abortAlgorithm=i;const l=qt(t);Pt(e,l),O(v(r()),()=>{t._started=!0,De(t)},u=>{t._started=!0,it(e,u)})}function je(e){e._writeAlgorithm=void 0,e._closeAlgorithm=void 0,e._abortAlgorithm=void 0,e._strategySizeAlgorithm=void 0}function kr(e){return e._strategyHWM-e._queueTotalSize}function De(e){const t=e._controlledWritableStream;if(!e._started||t._inFlightWriteRequest!==void 0)return;if(t._state==="erroring")return void Tt(t);if(e._queue.length===0)return;const r=e._queue.peek().value;r===Er?function(o){const n=o._controlledWritableStream;(function(s){s._inFlightCloseRequest=s._closeRequest,s._closeRequest=void 0})(n),Ke(o);const i=o._closeAlgorithm();je(o),O(i,()=>{(function(s){s._inFlightCloseRequest._resolve(void 0),s._inFlightCloseRequest=void 0,s._state==="erroring"&&(s._storedError=void 0,s._pendingAbortRequest!==void 0&&(s._pendingAbortRequest._resolve(),s._pendingAbortRequest=void 0)),s._state="closed";const a=s._writer;a!==void 0&&jr(a)})(n)},s=>{(function(a,l){a._inFlightCloseRequest._reject(l),a._inFlightCloseRequest=void 0,a._pendingAbortRequest!==void 0&&(a._pendingAbortRequest._reject(l),a._pendingAbortRequest=void 0),it(a,l)})(n,s)})}(e):function(o,n){const i=o._controlledWritableStream;(function(a){a._inFlightWriteRequest=a._writeRequests.shift()})(i);const s=o._writeAlgorithm(n);O(s,()=>{(function(l){l._inFlightWriteRequest._resolve(void 0),l._inFlightWriteRequest=void 0})(i);const a=i._state;if(Ke(o),!j(i)&&a==="writable"){const l=qt(o);Pt(i,l)}De(o)},a=>{i._state==="writable"&&je(o),function(l,u){l._inFlightWriteRequest._reject(u),l._inFlightWriteRequest=void 0,it(l,u)}(i,a)})}(e,r)}function st(e,t){e._controlledWritableStream._state==="writable"&&Or(e,t)}function qt(e){return kr(e)<=0}function Or(e,t){const r=e._controlledWritableStream;je(e),Rt(r,t)}function ye(e){return new TypeError(`WritableStream.prototype.${e} can only be used on a WritableStream`)}function Y(e){return new TypeError(`WritableStreamDefaultWriter.prototype.${e} can only be used on a WritableStreamDefaultWriter`)}function se(e){return new TypeError("Cannot "+e+" a stream using a released writer")}function Pe(e){e._closedPromise=q((t,r)=>{e._closedPromise_resolve=t,e._closedPromise_reject=r,e._closedPromiseState="pending"})}function Wr(e,t){Pe(e),Et(e,t)}function Et(e,t){e._closedPromise_reject!==void 0&&(he(e._closedPromise),e._closedPromise_reject(t),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState="rejected")}function jr(e){e._closedPromise_resolve!==void 0&&(e._closedPromise_resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState="resolved")}function xe(e){e._readyPromise=q((t,r)=>{e._readyPromise_resolve=t,e._readyPromise_reject=r}),e._readyPromiseState="pending"}function lt(e,t){xe(e),Ar(e,t)}function It(e){xe(e),Ct(e)}function Ar(e,t){e._readyPromise_reject!==void 0&&(he(e._readyPromise),e._readyPromise_reject(t),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState="rejected")}function Ct(e){e._readyPromise_resolve!==void 0&&(e._readyPromise_resolve(void 0),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState="fulfilled")}Object.defineProperties(We.prototype,{error:{enumerable:!0}}),typeof b.toStringTag=="symbol"&&Object.defineProperty(We.prototype,b.toStringTag,{value:"WritableStreamDefaultController",configurable:!0});const Lt=typeof DOMException!="undefined"?DOMException:void 0,eo=function(e){if(typeof e!="function"&&typeof e!="object")return!1;try{return new e,!0}catch{return!1}}(Lt)?Lt:function(){const e=function(t,r){this.message=t||"",this.name=r||"Error",Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor)};return Object.defineProperty(e.prototype=Object.create(Error.prototype),"constructor",{value:e,writable:!0,configurable:!0}),e}();function Mt(e,t,r,o,n,i){const s=Re(e),a=vr(t);e._disturbed=!0;let l=!1,u=v(void 0);return q((f,_)=>{let c;if(i!==void 0){if(c=()=>{const p=new eo("Aborted","AbortError"),R=[];o||R.push(()=>t._state==="writable"?Oe(t,p):v(void 0)),n||R.push(()=>e._state==="readable"?X(e,p):v(void 0)),w(()=>Promise.all(R.map(C=>C())),!0,p)},i.aborted)return void c();i.addEventListener("abort",c)}var y,g,m;if(S(e,s._closedPromise,p=>{o?I(!0,p):w(()=>Oe(t,p),!0,p)}),S(t,a._closedPromise,p=>{n?I(!0,p):w(()=>X(e,p),!0,p)}),y=e,g=s._closedPromise,m=()=>{r?I():w(()=>function(p){const R=p._ownerWritableStream,C=R._state;return j(R)||C==="closed"?v(void 0):C==="errored"?d(R._storedError):Rr(p)}(a))},y._state==="closed"?m():Ye(g,m),j(t)||t._state==="closed"){const p=new TypeError("the destination writable stream closed before all data could be piped to it");n?I(!0,p):w(()=>X(e,p),!0,p)}function h(){const p=u;return z(u,()=>p!==u?h():void 0)}function S(p,R,C){p._state==="errored"?C(p._storedError):Kt(R,C)}function w(p,R,C){function T(){O(p(),()=>L(R,C),P=>L(!0,P))}l||(l=!0,t._state!=="writable"||j(t)?T():Ye(h(),T))}function I(p,R){l||(l=!0,t._state!=="writable"||j(t)?L(p,R):Ye(h(),()=>L(p,R)))}function L(p,R){Pr(a),V(s),i!==void 0&&i.removeEventListener("abort",c),p?_(R):f(void 0)}he(q((p,R)=>{(function C(T){T?p():z(l?v(!0):z(a._readyPromise,()=>q((P,k)=>{$e(s,{_chunkSteps:M=>{u=z(qr(a,M),void 0,dt),P(!1)},_closeSteps:()=>P(!0),_errorSteps:k})})),C,R)})(!1)}))})}class Ae{constructor(){throw new TypeError("Illegal constructor")}get desiredSize(){if(!ge(this))throw ve("desiredSize");return kt(this)}close(){if(!ge(this))throw ve("close");if(!ne(this))throw new TypeError("The stream is not in a state that permits close");fe(this)}enqueue(t=void 0){if(!ge(this))throw ve("enqueue");if(!ne(this))throw new TypeError("The stream is not in a state that permits enqueue");return Be(this,t)}error(t=void 0){if(!ge(this))throw ve("error");x(this,t)}[bt](t){N(this);const r=this._cancelAlgorithm(t);return ze(this),r}[pt](t){const r=this._controlledReadableStream;if(this._queue.length>0){const o=Ke(this);this._closeRequested&&this._queue.length===0?(ze(this),_e(r)):de(this),t._chunkSteps(o)}else sr(r,t),de(this)}}function ge(e){return!!E(e)&&!!Object.prototype.hasOwnProperty.call(e,"_controlledReadableStream")}function de(e){if(!!zr(e)){if(e._pulling)return void(e._pullAgain=!0);e._pulling=!0,O(e._pullAlgorithm(),()=>{e._pulling=!1,e._pullAgain&&(e._pullAgain=!1,de(e))},t=>{x(e,t)})}}function zr(e){const t=e._controlledReadableStream;return!ne(e)||!e._started?!1:D(t)&&Me(t)>0?!0:kt(e)>0}function ze(e){e._pullAlgorithm=void 0,e._cancelAlgorithm=void 0,e._strategySizeAlgorithm=void 0}function fe(e){if(!ne(e))return;const t=e._controlledReadableStream;e._closeRequested=!0,e._queue.length===0&&(ze(e),_e(t))}function Be(e,t){if(!ne(e))return;const r=e._controlledReadableStream;if(D(r)&&Me(r)>0)gt(r,t,!1);else{let o;try{o=e._strategySizeAlgorithm(t)}catch(n){throw x(e,n),n}try{vt(e,t,o)}catch(n){throw x(e,n),n}}de(e)}function x(e,t){const r=e._controlledReadableStream;r._state==="readable"&&(N(e),ze(e),Ir(r,t))}function kt(e){const t=e._controlledReadableStream._state;return t==="errored"?null:t==="closed"?0:e._strategyHWM-e._queueTotalSize}function ne(e){const t=e._controlledReadableStream._state;return!e._closeRequested&&t==="readable"}function Br(e,t,r,o,n,i,s){t._controlledReadableStream=e,t._queue=void 0,t._queueTotalSize=void 0,N(t),t._started=!1,t._closeRequested=!1,t._pullAgain=!1,t._pulling=!1,t._strategySizeAlgorithm=s,t._strategyHWM=i,t._pullAlgorithm=o,t._cancelAlgorithm=n,e._readableStreamController=t,O(v(r()),()=>{t._started=!0,de(t)},a=>{x(t,a)})}function ve(e){return new TypeError(`ReadableStreamDefaultController.prototype.${e} can only be used on a ReadableStreamDefaultController`)}function to(e,t,r){return W(e,r),o=>K(e,t,[o])}function ro(e,t,r){return W(e,r),o=>K(e,t,[o])}function oo(e,t,r){return W(e,r),o=>Le(e,t,[o])}function no(e,t){if((e=""+e)!="bytes")throw new TypeError(`${t} '${e}' is not a valid enumeration value for ReadableStreamType`);return e}function io(e,t){if((e=""+e)!="byob")throw new TypeError(`${t} '${e}' is not a valid enumeration value for ReadableStreamReaderMode`);return e}function $t(e,t){B(e,t);const r=e==null?void 0:e.preventAbort,o=e==null?void 0:e.preventCancel,n=e==null?void 0:e.preventClose,i=e==null?void 0:e.signal;return i!==void 0&&function(s,a){if(!function(l){if(typeof l!="object"||l===null)return!1;try{return typeof l.aborted=="boolean"}catch{return!1}}(s))throw new TypeError(a+" is not an AbortSignal.")}(i,t+" has member 'signal' that"),{preventAbort:!!r,preventCancel:!!o,preventClose:!!n,signal:i}}Object.defineProperties(Ae.prototype,{close:{enumerable:!0},enqueue:{enumerable:!0},error:{enumerable:!0},desiredSize:{enumerable:!0}}),typeof b.toStringTag=="symbol"&&Object.defineProperty(Ae.prototype,b.toStringTag,{value:"ReadableStreamDefaultController",configurable:!0});class le{constructor(t={},r={}){t===void 0?t=null:ir(t,"First parameter");const o=ke(r,"Second parameter"),n=function(i,s){B(i,s);const a=i,l=a==null?void 0:a.autoAllocateChunkSize,u=a==null?void 0:a.cancel,f=a==null?void 0:a.pull,_=a==null?void 0:a.start,c=a==null?void 0:a.type;return{autoAllocateChunkSize:l===void 0?void 0:ar(l,s+" has member 'autoAllocateChunkSize' that"),cancel:u===void 0?void 0:to(u,a,s+" has member 'cancel' that"),pull:f===void 0?void 0:ro(f,a,s+" has member 'pull' that"),start:_===void 0?void 0:oo(_,a,s+" has member 'start' that"),type:c===void 0?void 0:no(c,s+" has member 'type' that")}}(t,"First parameter");if(Fr(this),n.type==="bytes"){if(o.size!==void 0)throw new RangeError("The strategy for a byte stream cannot have a size function");Vr(this,n,ce(o,0))}else{const i=Ce(o);(function(s,a,l,u){const f=Object.create(Ae.prototype);let _=()=>{},c=()=>v(void 0),y=()=>v(void 0);a.start!==void 0&&(_=()=>a.start(f)),a.pull!==void 0&&(c=()=>a.pull(f)),a.cancel!==void 0&&(y=g=>a.cancel(g)),Br(s,f,_,c,y,l,u)})(this,n,ce(o,1),i)}}get locked(){if(!$(this))throw H("locked");return D(this)}cancel(t=void 0){return $(this)?D(this)?d(new TypeError("Cannot cancel a stream that already has a reader")):X(this,t):d(H("cancel"))}getReader(t=void 0){if(!$(this))throw H("getReader");return function(r,o){B(r,o);const n=r==null?void 0:r.mode;return{mode:n===void 0?void 0:io(n,o+" has member 'mode' that")}}(t,"First parameter").mode===void 0?Re(this):new ot(this)}pipeThrough(t,r={}){if(!$(this))throw H("pipeThrough");F(t,1,"pipeThrough");const o=function(i,s){B(i,s);const a=i==null?void 0:i.readable;Xe(a,"readable","ReadableWritablePair"),yt(a,s+" has member 'readable' that");const l=i==null?void 0:i.writable;return Xe(l,"writable","ReadableWritablePair"),gr(l,s+" has member 'writable' that"),{readable:a,writable:l}}(t,"First parameter"),n=$t(r,"Second parameter");if(D(this))throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");if(re(o.writable))throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");return he(Mt(this,o.writable,n.preventClose,n.preventAbort,n.preventCancel,n.signal)),o.readable}pipeTo(t,r={}){if(!$(this))return d(H("pipeTo"));if(t===void 0)return d("Parameter 1 is required in 'pipeTo'.");if(!te(t))return d(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));let o;try{o=$t(r,"Second parameter")}catch(n){return d(n)}return D(this)?d(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream")):re(t)?d(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream")):Mt(this,t,o.preventClose,o.preventAbort,o.preventCancel,o.signal)}tee(){if(!$(this))throw H("tee");const t=function(r,o){const n=Re(r);let i,s,a,l,u,f=!1,_=!1,c=!1;const y=q(h=>{u=h});function g(){return f||(f=!0,$e(n,{_chunkSteps:h=>{Zt(()=>{f=!1;const S=h,w=h;_||Be(a._readableStreamController,S),c||Be(l._readableStreamController,w)})},_closeSteps:()=>{f=!1,_||fe(a._readableStreamController),c||fe(l._readableStreamController),_&&c||u(void 0)},_errorSteps:()=>{f=!1}})),v(void 0)}function m(){}return a=ut(m,g,function(h){if(_=!0,i=h,c){const S=He([i,s]),w=X(r,S);u(w)}return y}),l=ut(m,g,function(h){if(c=!0,s=h,_){const S=He([i,s]),w=X(r,S);u(w)}return y}),Kt(n._closedPromise,h=>{x(a._readableStreamController,h),x(l._readableStreamController,h),_&&c||u(void 0)}),[a,l]}(this);return He(t)}values(t=void 0){if(!$(this))throw H("values");return function(r,o){const n=Re(r),i=new Hr(n,o),s=Object.create(ur);return s._asyncIteratorImpl=i,s}(this,function(r,o){return B(r,o),{preventCancel:!!(r!=null&&r.preventCancel)}}(t,"First parameter").preventCancel)}}function ut(e,t,r,o=1,n=()=>1){const i=Object.create(le.prototype);return Fr(i),Br(i,Object.create(Ae.prototype),e,t,r,o,n),i}function Fr(e){e._state="readable",e._reader=void 0,e._storedError=void 0,e._disturbed=!1}function $(e){return!!E(e)&&!!Object.prototype.hasOwnProperty.call(e,"_readableStreamController")}function D(e){return e._reader!==void 0}function X(e,t){return e._disturbed=!0,e._state==="closed"?v(void 0):e._state==="errored"?d(e._storedError):(_e(e),G(e._readableStreamController[bt](t),dt))}function _e(e){e._state="closed";const t=e._reader;t!==void 0&&(rr(t),U(t)&&(t._readRequests.forEach(r=>{r._closeSteps()}),t._readRequests=new A))}function Ir(e,t){e._state="errored",e._storedError=t;const r=e._reader;r!==void 0&&(_t(r,t),U(r)?(r._readRequests.forEach(o=>{o._errorSteps(t)}),r._readRequests=new A):(r._readIntoRequests.forEach(o=>{o._errorSteps(t)}),r._readIntoRequests=new A))}function H(e){return new TypeError(`ReadableStream.prototype.${e} can only be used on a ReadableStream`)}function Lr(e,t){B(e,t);const r=e==null?void 0:e.highWaterMark;return Xe(r,"highWaterMark","QueuingStrategyInit"),{highWaterMark:mt(r)}}Object.defineProperties(le.prototype,{cancel:{enumerable:!0},getReader:{enumerable:!0},pipeThrough:{enumerable:!0},pipeTo:{enumerable:!0},tee:{enumerable:!0},values:{enumerable:!0},locked:{enumerable:!0}}),typeof b.toStringTag=="symbol"&&Object.defineProperty(le.prototype,b.toStringTag,{value:"ReadableStream",configurable:!0}),typeof b.asyncIterator=="symbol"&&Object.defineProperty(le.prototype,b.asyncIterator,{value:le.prototype.values,writable:!0,configurable:!0});const ao=function(e){return e.byteLength};class Dt{constructor(t){F(t,1,"ByteLengthQueuingStrategy"),t=Lr(t,"First parameter"),this._byteLengthQueuingStrategyHighWaterMark=t.highWaterMark}get highWaterMark(){if(!Nt(this))throw xt("highWaterMark");return this._byteLengthQueuingStrategyHighWaterMark}get size(){if(!Nt(this))throw xt("size");return ao}}function xt(e){return new TypeError(`ByteLengthQueuingStrategy.prototype.${e} can only be used on a ByteLengthQueuingStrategy`)}function Nt(e){return!!E(e)&&!!Object.prototype.hasOwnProperty.call(e,"_byteLengthQueuingStrategyHighWaterMark")}Object.defineProperties(Dt.prototype,{highWaterMark:{enumerable:!0},size:{enumerable:!0}}),typeof b.toStringTag=="symbol"&&Object.defineProperty(Dt.prototype,b.toStringTag,{value:"ByteLengthQueuingStrategy",configurable:!0});const so=function(){return 1};class Qt{constructor(t){F(t,1,"CountQueuingStrategy"),t=Lr(t,"First parameter"),this._countQueuingStrategyHighWaterMark=t.highWaterMark}get highWaterMark(){if(!Ht(this))throw Yt("highWaterMark");return this._countQueuingStrategyHighWaterMark}get size(){if(!Ht(this))throw Yt("size");return so}}function Yt(e){return new TypeError(`CountQueuingStrategy.prototype.${e} can only be used on a CountQueuingStrategy`)}function Ht(e){return!!E(e)&&!!Object.prototype.hasOwnProperty.call(e,"_countQueuingStrategyHighWaterMark")}function lo(e,t,r){return W(e,r),o=>K(e,t,[o])}function uo(e,t,r){return W(e,r),o=>Le(e,t,[o])}function co(e,t,r){return W(e,r),(o,n)=>K(e,t,[o,n])}Object.defineProperties(Qt.prototype,{highWaterMark:{enumerable:!0},size:{enumerable:!0}}),typeof b.toStringTag=="symbol"&&Object.defineProperty(Qt.prototype,b.toStringTag,{value:"CountQueuingStrategy",configurable:!0});class Vt{constructor(t={},r={},o={}){t===void 0&&(t=null);const n=ke(r,"Second parameter"),i=ke(o,"Third parameter"),s=function(c,y){B(c,y);const g=c==null?void 0:c.flush,m=c==null?void 0:c.readableType,h=c==null?void 0:c.start,S=c==null?void 0:c.transform,w=c==null?void 0:c.writableType;return{flush:g===void 0?void 0:lo(g,c,y+" has member 'flush' that"),readableType:m,start:h===void 0?void 0:uo(h,c,y+" has member 'start' that"),transform:S===void 0?void 0:co(S,c,y+" has member 'transform' that"),writableType:w}}(t,"First parameter");if(s.readableType!==void 0)throw new RangeError("Invalid readableType specified");if(s.writableType!==void 0)throw new RangeError("Invalid writableType specified");const a=ce(i,0),l=Ce(i),u=ce(n,1),f=Ce(n);let _;(function(c,y,g,m,h,S){function w(){return y}function I(T){return function(P,k){const M=P._transformStreamController;return P._backpressure?G(P._backpressureChangePromise,()=>{const Z=P._writable;if(Z._state==="erroring")throw Z._storedError;return Gt(M,k)}):Gt(M,k)}(c,T)}function L(T){return function(P,k){return Fe(P,k),v(void 0)}(c,T)}function p(){return function(T){const P=T._readable,k=T._transformStreamController,M=k._flushAlgorithm();return Mr(k),G(M,()=>{if(P._state==="errored")throw P._storedError;fe(P._readableStreamController)},Z=>{throw Fe(T,Z),P._storedError})}(c)}function R(){return function(T){return Ie(T,!1),T._backpressureChangePromise}(c)}function C(T){return Ne(c,T),v(void 0)}c._writable=function(T,P,k,M,Z=1,Dr=()=>1){const Qe=Object.create(nt.prototype);return wr(Qe),Cr(Qe,Object.create(We.prototype),T,P,k,M,Z,Dr),Qe}(w,I,p,L,g,m),c._readable=ut(w,R,C,h,S),c._backpressure=void 0,c._backpressureChangePromise=void 0,c._backpressureChangePromise_resolve=void 0,Ie(c,!0),c._transformStreamController=void 0})(this,q(c=>{_=c}),u,f,a,l),function(c,y){const g=Object.create(ct.prototype);let m=S=>{try{return $r(g,S),v(void 0)}catch(w){return d(w)}},h=()=>v(void 0);y.transform!==void 0&&(m=S=>y.transform(S,g)),y.flush!==void 0&&(h=()=>y.flush(g)),function(S,w,I,L){w._controlledTransformStream=S,S._transformStreamController=w,w._transformAlgorithm=I,w._flushAlgorithm=L}(c,g,m,h)}(this,s),s.start!==void 0?_(s.start(this._transformStreamController)):_(void 0)}get readable(){if(!Ut(this))throw Xt("readable");return this._readable}get writable(){if(!Ut(this))throw Xt("writable");return this._writable}}function Ut(e){return!!E(e)&&!!Object.prototype.hasOwnProperty.call(e,"_transformStreamController")}function Fe(e,t){x(e._readable._readableStreamController,t),Ne(e,t)}function Ne(e,t){Mr(e._transformStreamController),st(e._writable._writableStreamController,t),e._backpressure&&Ie(e,!1)}function Ie(e,t){e._backpressureChangePromise!==void 0&&e._backpressureChangePromise_resolve(),e._backpressureChangePromise=q(r=>{e._backpressureChangePromise_resolve=r}),e._backpressure=t}Object.defineProperties(Vt.prototype,{readable:{enumerable:!0},writable:{enumerable:!0}}),typeof b.toStringTag=="symbol"&&Object.defineProperty(Vt.prototype,b.toStringTag,{value:"TransformStream",configurable:!0});class ct{constructor(){throw new TypeError("Illegal constructor")}get desiredSize(){if(!we(this))throw Se("desiredSize");return kt(this._controlledTransformStream._readable._readableStreamController)}enqueue(t=void 0){if(!we(this))throw Se("enqueue");$r(this,t)}error(t=void 0){if(!we(this))throw Se("error");var r;r=t,Fe(this._controlledTransformStream,r)}terminate(){if(!we(this))throw Se("terminate");(function(t){const r=t._controlledTransformStream;fe(r._readable._readableStreamController),Ne(r,new TypeError("TransformStream terminated"))})(this)}}function we(e){return!!E(e)&&!!Object.prototype.hasOwnProperty.call(e,"_controlledTransformStream")}function Mr(e){e._transformAlgorithm=void 0,e._flushAlgorithm=void 0}function $r(e,t){const r=e._controlledTransformStream,o=r._readable._readableStreamController;if(!ne(o))throw new TypeError("Readable side is not in a state that permits enqueue");try{Be(o,t)}catch(i){throw Ne(r,i),r._readable._storedError}(function(i){return!zr(i)})(o)!==r._backpressure&&Ie(r,!0)}function Gt(e,t){return G(e._transformAlgorithm(t),void 0,r=>{throw Fe(e._controlledTransformStream,r),r})}function Se(e){return new TypeError(`TransformStreamDefaultController.prototype.${e} can only be used on a TransformStreamDefaultController`)}function Xt(e){return new TypeError(`TransformStream.prototype.${e} can only be used on a TransformStream`)}Object.defineProperties(ct.prototype,{enqueue:{enumerable:!0},error:{enumerable:!0},terminate:{enumerable:!0},desiredSize:{enumerable:!0}}),typeof b.toStringTag=="symbol"&&Object.defineProperty(ct.prototype,b.toStringTag,{value:"TransformStreamDefaultController",configurable:!0});export{Dt as ByteLengthQueuingStrategy,Qt as CountQueuingStrategy,et as ReadableByteStreamController,le as ReadableStream,ot as ReadableStreamBYOBReader,Ze as ReadableStreamBYOBRequest,Ae as ReadableStreamDefaultController,Je as ReadableStreamDefaultReader,Vt as TransformStream,ct as TransformStreamDefaultController,nt as WritableStream,We as WritableStreamDefaultController,at as WritableStreamDefaultWriter};
